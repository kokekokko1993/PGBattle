#include <bits/stdc++.h>
using namespace std;

/*
R[i][j]: 下からi桁目(0-orizin)の数字がjとなる、0以上N以下の整数の個数
※上位の桁が0でもよいとする -> 0は何回現れても足すと0だからOK
答えはj x R[i][j]の総和

N=723でi=1を考えると
R[1][0]=R[1][1]=80(=70+10), R[1][2]=74(=70+4), R[1][3]~R[1][9]=70となる
・0~699では、10の位に0~9が70回ずつ出現
・700~719では、10の位に0~1が10回ずつ出現
・720~723では、10の位に2が4回ずつ出現

まとめると
・j<(10の位の値)： R[1][j]=[N/100]*10+10
・j<(10の位の値)： R[1][j]=[N/100]*10+(N mod 10 + 1)
・j<(10の位の値)： R[1][j]=[N/100]*10

一般の(i, j)に対しては
・j<(10^iの位の値)： R[1][j]=[N/10^(i+1)]*10^i+10^i
・j<(10^iの位の値)： R[1][j]=[N/10^(i+1)]*10^i+(N mod 10^i + 1)
・j<(10^iの位の値)： R[1][j]=[N/10^(i+1)]*10^i
-> 今回の問題ではN<10^15なのでi=14まで必要！
*/

long long N;
long long R[15][10];
long long p10[19];

int main() {
    cin >> N;
    p10[0] = 1;
    for (int i = 1; i < 18; i++) {
        p10[i] = p10[i - 1] * 10;
    }

    for (int i = 0; i <= 14; i++) {
        for (int j = 0; j <= 9; j++) {
            int base = (N / p10[i]) % 10;
            if (j < base) {
                R[i][j] = (N / p10[i + 1]) * p10[i] + p10[i];
            } else if (j == base) {
                R[i][j] = (N / p10[i + 1]) * p10[i] + (N % p10[i] + 1);
            } else {
                R[i][j] = (N / p10[i + 1]) * p10[i];
            }
        }
    }

    long long ans = 0;
    for (int i = 0; i <= 14; i++) {
        for (int j = 0; j <= 9; j++) {
            ans += j * R[i][j];
        }
    }
    cout << ans << endl;
    return 0;
}